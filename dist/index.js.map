{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["\n/**\n * Datastar Persist Plugin - Simple Sequential Implementation\n * Handles data-persist attributes for automatic signal persistence to storage\n * No throttling - saves immediately on every signal change\n */\nimport { attribute } from \"datastar\";\nimport { effect, getPath, mergePatch, beginBatch, endBatch } from 'datastar';\n\ninterface PersistConfig {\n  storage: Storage;\n  storageKey: string;\n  signals: string[];\n  isWildcard: boolean;\n}\n\nconst DEFAULT_STORAGE_KEY = \"datastar\";\n\nfunction getStorage(isSession: boolean): Storage | null {\n  try {\n    const storage = isSession ? sessionStorage : localStorage;\n    const testKey = \"__test__\";\n    storage.setItem(testKey, \"1\");\n    storage.removeItem(testKey);\n    return storage;\n  } catch {\n    return null;\n  }\n}\n\nfunction parseConfig(key: string | null, value: any, mods: Map<string, Set<string>>, el: HTMLElement): PersistConfig | null {\n  const isSession = mods.has(\"session\");\n  const storage = getStorage(isSession);\n  if (!storage) return null;\n\n  const storageKey = key ? `${DEFAULT_STORAGE_KEY}-${key}` : DEFAULT_STORAGE_KEY;\n\n  let signals: string[] = [];\n  let isWildcard = false;\n\n  // Get raw attribute value from element\n  let rawValue = value;\n  if (value === undefined || value === null || (typeof value !== 'string')) {\n    rawValue = el.getAttribute('data-persist') || el.getAttribute('data-persist:' + (key || '')) || '';\n  }\n\n  const trimmedValue = typeof rawValue === 'string' ? rawValue.trim() : '';\n\n  if (trimmedValue) {\n    signals = trimmedValue\n      .split(\",\")\n      .map((s) => s.trim())\n      .filter(Boolean);\n  } else {\n    isWildcard = true;\n  }\n\n  return { storage, storageKey, signals, isWildcard };\n}\n\nfunction loadFromStorage(config: PersistConfig): void {\n  try {\n    const stored = config.storage.getItem(config.storageKey);\n    if (!stored) return;\n\n    const data = JSON.parse(stored);\n    if (!data || typeof data !== \"object\") return;\n\n    beginBatch();\n    try {\n      if (config.isWildcard) {\n        mergePatch(data);\n      } else {\n        const patch = Object.fromEntries(\n          config.signals.filter((signal) => signal in data).map((signal) => [signal, data[signal]])\n        );\n        if (Object.keys(patch).length > 0) {\n          mergePatch(patch);\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  } catch {\n    // Silent fail on storage errors\n  }\n}\n\nfunction getSignalsFromElement(el: HTMLElement): string[] {\n  const signals: string[] = [];\n\n  // Scan for data-signals:signalName attributes\n  for (const attr of el.attributes) {\n    if (attr.name.startsWith(\"data-signals:\")) {\n      const signalName = attr.name.substring(\"data-signals:\".length);\n      if (signalName) signals.push(signalName);\n    }\n  }\n\n  // Check for data-signals=\"{...}\" syntax\n  const signalsAttr = el.getAttribute(\"data-signals\");\n  if (signalsAttr) {\n    try {\n      const keyMatches = signalsAttr.matchAll(/(\\w+)\\s*:/g);\n      for (const match of keyMatches) {\n        if (match[1] && !signals.includes(match[1])) {\n          signals.push(match[1]);\n        }\n      }\n    } catch {\n      // Ignore parsing errors\n    }\n  }\n\n  return signals;\n}\n\nfunction saveToStorage(config: PersistConfig, signalData: Record<string, any>): void {\n  try {\n    const stored = config.storage.getItem(config.storageKey);\n    const existing = stored ? JSON.parse(stored) : {};\n    const merged = { ...existing, ...signalData };\n\n    if (Object.keys(merged).length > 0) {\n      config.storage.setItem(config.storageKey, JSON.stringify(merged));\n    }\n  } catch {\n    // Storage quota exceeded or other errors\n  }\n}\n\nconsole.log('[Persist Plugin] Loaded');\n\n// Track loaded keys to avoid duplicate loads\nconst loadedKeys = new Set<string>();\n\n// EXPERIMENTAL: Immediately load persisted data when module loads\n// This runs BEFORE Datastar processes DOM, so persisted values are set first\n// Use data-signals__ifmissing in HTML to prevent overwriting these values\n(function attemptEarlyLoad() {\n  console.log('[Persist Plugin] Attempting early load from storage');\n\n  try {\n    const storage = localStorage;\n    const stored = storage.getItem(DEFAULT_STORAGE_KEY);\n\n    if (stored) {\n      console.log(`[Persist Plugin] Found persisted data:`, stored);\n      const data = JSON.parse(stored);\n\n      if (data && typeof data === 'object' && Object.keys(data).length > 0) {\n        console.log(`[Persist Plugin] Restoring signals:`, Object.keys(data));\n\n        // Apply immediately - this sets signals BEFORE DOM processing\n        beginBatch();\n        try {\n          mergePatch(data);\n          loadedKeys.add(DEFAULT_STORAGE_KEY);\n          console.log(`[Persist Plugin] \u2713 Persisted values restored early`);\n        } finally {\n          endBatch();\n        }\n      }\n    } else {\n      console.log('[Persist Plugin] No persisted data found');\n    }\n  } catch (e) {\n    console.warn('[Persist Plugin] Early load failed:', e);\n  }\n})();\n\nattribute({\n  name: 'persist',\n  requirement: 'optional',\n  apply({ el, key, mods, value }) {\n    console.log('[Persist Plugin] Apply called', { el, key, value });\n    const config = parseConfig(key ?? null, value, mods, el as HTMLElement);\n    if (!config) {\n      console.warn('[Persist Plugin] No config');\n      return;\n    }\n    console.log('[Persist Plugin] Config:', config);\n\n    // Step 1: Load from storage if not already loaded\n    if (!loadedKeys.has(config.storageKey)) {\n      console.log('[Persist Plugin] Loading from storage');\n      loadFromStorage(config);\n      loadedKeys.add(config.storageKey);\n    } else {\n      console.log('[Persist Plugin] Already loaded (using early-loaded values)');\n    }\n\n    // Step 2: Watch signals and save on change\n    const cleanup = effect(() => {\n      const signals = config.isWildcard ? getSignalsFromElement(el as HTMLElement) : config.signals;\n      const data: Record<string, any> = {};\n\n      // Collect current signal values\n      for (const signal of signals) {\n        try {\n          data[signal] = getPath(signal);\n        } catch {\n          // Signal not found, skip\n        }\n      }\n\n      // Step 3: Save to storage\n      if (Object.keys(data).length > 0) {\n        saveToStorage(config, data);\n      }\n    });\n\n    return cleanup;\n  },\n});\n"],
  "mappings": "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",
  "names": ["attribute", "effect", "getPath", "mergePatch", "beginBatch", "endBatch", "DEFAULT_STORAGE_KEY", "getStorage", "isSession", "storage", "testKey", "parseConfig", "key", "value", "mods", "el", "storageKey", "signals", "isWildcard", "rawValue", "trimmedValue", "s", "loadFromStorage", "config", "stored", "data", "patch", "signal", "getSignalsFromElement", "attr", "signalName", "signalsAttr", "keyMatches", "match", "saveToStorage", "signalData", "merged", "loadedKeys"]
}
